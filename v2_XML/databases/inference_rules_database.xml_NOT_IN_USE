<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is an exhaustive list of all possible inference_rules which act on statements in physics -->
<!-- Note: inference rule names cannot have numbers in them (due to Latex parsing of name) -->
<!-- convention: in Latex string, all equation labels come after the feed strings. Example:
        In Eq.~\ref{eq:#2}, rejigger scalar $#1$. -->
<!-- (number of arguments) does not equal (feeds + inputs). Example: declareInitEq -->
<!--
   <inference_rule>
      <infrule_name></infrule_name>
      <latex_expansion></latex_expansion>
      <comment></comment>
      <check></check>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <relation_to_other_inference_rule></relation_to_other_inference_rule>
      <number_of_arguments></number_of_arguments> <!- - for the latex expansion - ->
      <number_of_feeds></number_of_feeds> <!- - how many of the arguments are not equations - ->
      <number_of_input_statements></number_of_input_statements> <!- - how many of the arguments are equation - ->
      <number_of_output_statements></number_of_output_statements>
   </inference_rule>
-->
<inference_rule_list>
   <inference_rule>
      <infrule_name>subXforY</infrule_name>
      <latex_expansion>Substitute $#1$ for $#2$ in Eq.~\ref{eq:#3}.</latex_expansion>
      <!-- keywords: replace, substitute. for substitutions like "x" becomes "2x" -->
      <cas_mathematica></cas_mathematica>
<!-- 
replaceThis = feed0
withThis = feed1
 -->
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == in_lhs0.subs(feed0,feed1)) and (out_rhs0 == in_rhs0.subs(feed0,feed1)))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>3</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <!-- \newcommand{\subXforY}[3]{Substitute $#1$ for $#2$ in Eq.~\ref{eq:#3}.} -->
      <number_of_feeds>2</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
<!--
statement 1: A+z = B+g
rule: substitute z for k
statement 2: A+k = B+g
-->
   </inference_rule>
   <inference_rule>
      <infrule_name>functionIsEven</infrule_name>
      <latex_expansion>$#1$ is even with respect to $#2$, so replace $#1$ with $#3$ in Eq.~\ref{eq:#4}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- 
      sympy.cos(x)==sympy.cos(-x) 
 -->
      </cas_sympy>
      <number_of_arguments>4</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>3</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>functionIsOdd</infrule_name>
      <latex_expansion>$#1$ is odd with respect to $#2$, so replace $#1$ with $#3$ in Eq.~\ref{eq:#4}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- 
      sympy.sin(-x)==-sympy.sin(x)      
 -->
      </cas_sympy>
      <number_of_arguments>4</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>3</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>AssumeNdimensions</infrule_name>
      <latex_expansion>Assume $#1$ dimensions in Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>2</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>1</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>0</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>ReplaceCurlWithLeviCevitaSummationContravariant</infrule_name>
      <latex_expansion>Replace curl in Eq.~\ref{eq:#1} with Levi-Cevita contravariant.</latex_expansion>
      <comment>Einstein summation notation</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>ReplaceSummationNotationWithVectorNotation</infrule_name>
      <latex_expansion>Replace summation notation in Eq.~\ref{eq:#1} with vector notation.</latex_expansion>
      <comment>Einstein summation notation</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>replaceScalarWithVector</infrule_name>
      <latex_expansion>Replace scalar variables in Eq.~\ref{eq:#1} with equivalent vector variables.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>conjugateFunctionX</infrule_name>
      <latex_expansion>Conjugate $#1$ in Eq.~\ref{eq:#2}.</latex_expansion>
      <!-- keyword: complex conjugate -->
      <cas_mathematica>replace f with f^*; replace $i$ with $-i$</cas_mathematica>
      <cas_sympy>	      
<!-- 
      sympy.conjugate(sympy.I)==-sympy.I
 -->
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>1</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>conjugateBothSides</infrule_name>
      <latex_expansion>Conjugate both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <!-- keyword: complex conjugate -->
      <cas_mathematica>Apply ^*; replace $i$ with $-i$</cas_mathematica>
      <cas_sympy>	      
<!-- 
      sympy.conjugate(sympy.I)==-sympy.I
 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>conjugateTransposeBothSides</infrule_name>
      <latex_expansion>Conjugate transpose of both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <comment>this is a combination of "apply conjugate" and then "apply transpose"</comment>
      <!-- keyword: Hermitian conjugate, adjoint matrix, Hermitian transpose -->
      <cas_mathematica>Apply ^+; replace $i$ with $-i$ and transpose matrices</cas_mathematica>
      <cas_sympy>	      
<!-- 
      sympy.conjugate(sympy.I)==-sympy.I
 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>distributeConjugateTransposeToFactors</infrule_name>
      <latex_expansion>Distribute conjugate transpose to factors in Eq.~\ref{eq:#1}.</latex_expansion>
      <!-- keyword: Hermitian conjugate, adjoint matrix, Hermitian transpose -->
      <comment>this is a combination of "distribute conjugate" and then "distribute transpose"</comment>
      <cas_mathematica>Apply ^+; replace $i$ with $-i$ and transpose matrices, rotate bra-ket.</cas_mathematica>
      <cas_sympy>	      
<!-- 
      sympy.conjugate(sympy.I)==-sympy.I
 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>distributeConjugateToFactors</infrule_name>
      <latex_expansion>Distribute conjugate to factors in Eq.~\ref{eq:#1}.</latex_expansion>
      <!-- keyword: complex conjugate -->
      <cas_mathematica>Apply ^*; replace $i$ with $-i$</cas_mathematica>
      <cas_sympy>	      
<!-- 
      sympy.conjugate(sympy.I)==-sympy.I
 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>0</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>expandMagnitudeToConjugate</infrule_name>
      <latex_expansion>Expand $#1$ in Eq.~\ref{eq:#2} with conjugate.</latex_expansion>
      <!-- keyword: expansion -->
      <cas_mathematica>replace |f|^2 with ff^*</cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>2</number_of_arguments> <!-- for the "#1", "#2", "#3" in the latex expansion -->
      <number_of_feeds>1</number_of_feeds> <!-- how many of the arguments are not equations -->
      <number_of_input_statements>1</number_of_input_statements> <!-- how many of the arguments are equation -->
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>multLHSbyUnity</infrule_name>
      <latex_expansion>Multiply LHS of Eq.~\ref{eq:#2} by 1, which in this case is $#1$</latex_expansion>
      <check>argument 2 must evaluate to unity</check>
      <relation_to_other_inference_rule>compliment of multRHSbyUnity</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try: 
  rule_obeyed = ((feed0==1) and (out_lhs0 == (in_lhs0*feed0)) and (out_rhs0 == in_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>multRHSbyUnity</infrule_name>
      <latex_expansion>Multiply RHS of Eq.~\ref{eq:#2} by 1, which in this case is $#1$</latex_expansion>
      <check>argument 2 must evaluate to 1</check>
      <relation_to_other_inference_rule>compliment of multLHSbyUnity</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((feed0==1) and (out_lhs0 == (in_lhs0)) and (out_rhs0 == in_rhs0*feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>multbothsidesby</infrule_name>
      <latex_expansion>Multiply both sides of Eq.~\ref{eq:#2} by $#1$.</latex_expansion>
      <relation_to_other_inference_rule>inverse of dividebothsidesby</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (in_lhs0*feed0)) and (out_rhs0 == in_rhs0*feed0))
except:
  rule_obeyed =  5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>dividebothsidesby</infrule_name>
      <latex_expansion>Divide both sides of Eq.~\ref{eq:#2} by $#1$.</latex_expansion>
      <check>argument cannot be zero</check>
      <relation_to_other_inference_rule>inverse of multbothsidesby</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (in_lhs0/feed0)) and (out_rhs0 == in_rhs0/feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>expandIntegrand</infrule_name>
      <latex_expansion>Expand integrand of Eq.~\ref{eq:#1}.</latex_expansion>
      <check></check>
      <relation_to_other_inference_rule></relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- 
http://docs.sympy.org/dev/modules/rewriting.html
(x + I*y).expand(complex=True)
 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>addZerotoLHS</infrule_name>
      <latex_expansion>Add zero to LHS of Eq.~\ref{eq:#2}, where $0=#1$.</latex_expansion>
      <check>argument must evaluate to 0</check>
      <relation_to_other_inference_rule>compliment of addZerotoRHS</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- 
in_lhs0 = 
in_rhs0 = 
zero = 
out_lhs0 = 
out_rhs0 = 
 -->
try:
  rule_obeyed = ((zero==0) and (out_lhs0 == (in_lhs0+zero)) and (out_rhs0 == in_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>addZerotoRHS</infrule_name>
      <latex_expansion>Add zero to RHS of Eq.~\ref{eq:#2}, where $0=#1$.</latex_expansion>
      <check>argument must evaluate to 0</check>
      <relation_to_other_inference_rule>compliment of addZerotoLHS</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- 
in_lhs0 = 
in_rhs0 = 
zero = 
out_lhs0 = 
out_rhs0 = 
 -->
try:
  rule_obeyed = ((zero==0) and (out_lhs0 == (in_lhs0)) and (out_rhs0 == in_rhs0+zero))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>addXtoBothSides</infrule_name>
      <latex_expansion>Add $#1$ to both sides of Eq.~\ref{eq:#2}.</latex_expansion>
      <relation_to_other_inference_rule>compliment of subtractXfromBothSides</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (in_lhs0+feed0)) and (out_rhs0 == in_rhs0+feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>subtractXfromBothSides</infrule_name>
      <latex_expansion>Subtract $#1$ from both sides of Eq.~\ref{eq:#2}.</latex_expansion>
      <relation_to_other_inference_rule>compliment of addXtoBothSides</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (in_lhs0+feed0)) and (out_rhs0 == in_rhs0+feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>combineLikeTerms</infrule_name>
      <latex_expansion>Combine like terms in Eq.~\ref{eq:#1}.</latex_expansion>
      <relation_to_other_inference_rule>more explicit instance of simplify</relation_to_other_inference_rule>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>takeCurlofBothSides</infrule_name>
      <latex_expansion>Apply curl to both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <comment>Curl: $\vec{\nabla}\times$</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (\nabla \times in_lhs0)) and (out_rhs0 == \nabla \times in_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>applyGradientToScalarFunction</infrule_name>
      <latex_expansion>Apply gradient to both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <comment>Curl: $\vec{\nabla}f$</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>applyDivergence</infrule_name>
      <latex_expansion>Apply divergence to both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <comment>Curl: $\vec{\nabla} \cdot$</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>indefIntOver</infrule_name>
      <latex_expansion>Indefinite integral of both sides of Eq.~\ref{eq:#2} over $#1$.</latex_expansion>
      <comment>indefinite integral over variable</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (\int in_lhs0 feed0)) and (out_rhs0 == \int in_rhs0 feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>indefIntegration</infrule_name>
      <latex_expansion>Indefinite integral of both sides of Eq.~\ref{eq:#1}.</latex_expansion>
      <comment>indefinite integral</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (\int in_lhs0 )) and (out_rhs0 == \int in_rhs0 ))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>indefIntLHSOver</infrule_name>
      <latex_expansion>Indefinite integral of LHS of Eq.~\ref{eq:#2} over $#1$.</latex_expansion>
      <comment>indefinite integral over variable</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (\int in_lhs0 feed0)) and (out_rhs0 == in_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>indefIntRHSOver</infrule_name>
      <number_of_arguments>2</number_of_arguments>
      <latex_expansion>Indefinite integral of RHS of Eq.~\ref{eq:#2} over $#1$.</latex_expansion>
      <comment>indefinite integral over variable</comment>
      <cas_mathematica>Integrate[#2,#1]</cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == in_lhs0) and (out_rhs0 == \int in_rhs0 feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>IntOverFromTo</infrule_name>
      <latex_expansion>Integrate Eq.~\ref{eq:#4} over $#1$ from lower limit $#2$ to upper limit $#3$.</latex_expansion>
      <comment>$\int_{#2}^{#3}\ d #1$</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (\int_{feed1}^{feed2} in_lhs0 feed0)) and (out_rhs0 == \int_{feed1}^{feed2} in_rhs0 feed0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>4</number_of_arguments>
      <number_of_feeds>3</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>EvaluateDefiniteIntegral</infrule_name>
      <latex_expansion>Integrate Eq.~\ref{eq:#1} using identity Eq.~\ref{eq:#2}.</latex_expansion>
      <comment></comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>differentiateWRT</infrule_name>
      <number_of_arguments>2</number_of_arguments>
      <latex_expansion>Differentiate Eq.~\ref{eq:#2} with respect to $#1$.</latex_expansion>
      <comment>\frac{d}{d #1}</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>partialDiffWRT</infrule_name>
      <number_of_arguments>2</number_of_arguments>
      <latex_expansion>Partially differentiate Eq.~\ref{eq:#2} with respect to $#1$.</latex_expansion>
      <comment>\frac{\partial}{\partial #1}</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>Xcrossbothsidesby</infrule_name>
      <number_of_arguments>2</number_of_arguments>
      <latex_expansion>Take cross product of $#1$ and Eq.~\ref{eq:#2}.</latex_expansion>
      <comment>arg x LHS = arg x RHS</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments></number_of_arguments>
      <number_of_feeds></number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>bothsidescrossX</infrule_name>
      <number_of_arguments>2</number_of_arguments>
      <latex_expansion>Take cross product of Eq.~\ref{eq:#2} and $#1$</latex_expansion>
      <comment>LHS x arg = RHS x arg</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments></number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>Xdotbothsides</infrule_name>
      <latex_expansion>Take inner product of $#1$ with Eq.~\ref{eq:#2}.</latex_expansion>
      <comment>arg \cdot LHS = arg \cdot RHS</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>bothsidesdotX</infrule_name>
      <latex_expansion>Take inner product of Eq.~\ref{eq:#2} with $#1$</latex_expansion>
      <comment>LHS \cdot arg = RHS \cdot arg</comment>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>solveForX</infrule_name>
      <latex_expansion>Solve Eq.~\ref{eq:#2} for $#1$.</latex_expansion>
      <cas_mathematica>Solve[#1,#2]</cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>factorOutX</infrule_name>
      <latex_expansion>Factor $#1$ from Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>factorOutXfromLHS</infrule_name>
      <latex_expansion>Factor $#1$ from the LHS of Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>factorOutXfromRHS</infrule_name>
      <latex_expansion>Factor $#1$ from the RHS of Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
<!-- quantum mechanics -->
   <inference_rule>
      <infrule_name>applyOperatorToKet</infrule_name>
      <inference_rule_type>quantum mechanics</inference_rule_type>
      <latex_expansion>Apply operator to ket in Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>applyOperatorToBra</infrule_name>
      <inference_rule_type>quantum mechanics</inference_rule_type>
      <latex_expansion>Apply operator to bra in Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
<!-- manipulation -->
   <inference_rule>
      <infrule_name>simplify</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Simplify Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica>Simplify[#1]</cas_mathematica>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>makeEqPower</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Make Eq.~\ref{eq:#2} the power of $#1$.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (feed0)**(in_lhs0)) and (out_rhs0 == (feed0)**(in_rhs0)))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>selectRealParts</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Select real parts of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- sympy.re(2+3*sympy.I)==2 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>selectImagParts</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Select imaginary parts of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
<!-- sympy.im(2+3*sympy.I)==3 -->
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>expandLHS</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Expand the LHS of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>expandRHS</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Expand the RHS of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>swapLHSwithRHS</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Swap LHS of Eq.~\ref{eq:#1} with RHS.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_lhs0 == out_rhs0) and (in_rhs0 == out_lhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>sumExponents</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Sum exponents on LHS and RHS of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>sumExponentsLHS</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Sum exponents on LHS of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((?) and (in_rhs0 == out_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>sumExponentsRHS</infrule_name>
      <inference_rule_type>manipulation</inference_rule_type>
      <latex_expansion>Sum exponents on RHS of Eq.~\ref{eq:#1}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_lhs0 == out_lhs0) and (?))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
<!-- combining multiple equations -->
   <inference_rule>
      <infrule_name>addEqXtoEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>Add Eq.~\ref{eq:#1} to Eq.~\ref{eq:#2}.</latex_expansion>
      <comment>assumes result form LHS(X)+LHS(Y)=RHS(X)+RHS(Y)</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = (((in_lhs0+in_lhs1)==out_lhs0) and ((in_rhs0+in_rhs1)==out_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>subRHSofEqXintoEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>Substitute RHS of Eq.~\ref{eq:#1} into Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>subLHSofEqXintoEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>Substitute LHS of Eq.~\ref{eq:#1} into Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy></cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>multEqXbyEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>Multiply Eq.~\ref{eq:#1} by Eq.~\ref{eq:#2}.</latex_expansion>
      <comment>assumes result form LHS(X)*LHS(Y)=RHS(X)*RHS(Y)</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_lhs0*in_lhs1 == out_lhs0) and (in_rhs0*in_rhs1 == out_rhs0))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>LHSofEqXeqLHSofEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>LHS of Eq.~\ref{eq:#1} is equal to LHS of Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_lhs0 == in_lhs1) and (out_lhs0 == in_rhs0) and (out_rhs0 == in_rhs1))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>RHSofEqXeqRHSofEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>RHS of Eq.~\ref{eq:#1} is equal to RHS of Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_rhs0 == in_rhs1) and (out_lhs0 == in_lhs0) and (out_rhs0 == in_lhs1))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>EqXisTrueUnderconditionEqY</infrule_name>
      <inference_rule_type>combining multiple equations</inference_rule_type>
      <latex_expansion>Eq.~\ref{eq:#1} is valid when Eq.~\ref{eq:#2} occurs.</latex_expansion>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
<!-- these are a combination of other simpler commands: -->
   <inference_rule>
      <infrule_name>raiseBothSidesToPower</infrule_name>
      <latex_expansion>Raise both sides of Eq.~\ref{eq:#2} to $#1$.</latex_expansion>
      <comment>Two outputs for +/- solutions</comment>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((out_lhs0 == (in_lhs0)**(feed0)) and (out_rhs0 == (in_rhs0)**(feed0)))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>1</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>2</number_of_output_statements>
<!-- declare the beginning and end -->
   </inference_rule>
   <inference_rule>
      <infrule_name>claimEqXequalsEqY</infrule_name>
      <latex_expansion>Thus we see that Eq.~\ref{eq:#1} is equivalent to Eq.~\ref{eq:#2}.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = ((in_lhs0 == in_lhs1) and (in_rhs0 == in_rhs1))
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>2</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>2</number_of_input_statements>
      <number_of_output_statements>0</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>claimLHSequalsRHS</infrule_name>
      <latex_expansion>Thus we see that LHS of Eq.~\ref{eq:#1} is equal to RHS.</latex_expansion>
      <cas_mathematica></cas_mathematica>
      <cas_sympy>
try:
  rule_obeyed = (in_lhs0 == in_rhs0)
except:
  rule_obeyed = 5 # used to indicate problem
      </cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>0</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>declareIdentity</infrule_name>
      <latex_expansion>Eq.~\ref{eq:#1} is an identity.</latex_expansion>
      <comment></comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>0</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>normalizationCondition</infrule_name>
      <latex_expansion>Normalization condition is Eq.~\ref{eq:#1}.</latex_expansion>
      <comment></comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>0</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>declareInitialEq</infrule_name>
      <latex_expansion>Eq.~\ref{eq:#1} is an initial equation.</latex_expansion>
      <comment>pass label of starting equation</comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>0</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>declareAssumption</infrule_name>
      <latex_expansion>Eq.~\ref{eq:#1} is an assumption.</latex_expansion>
      <comment>pass label of starting equation</comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>0</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>declareGuessSolution</infrule_name>
      <latex_expansion>Judicious choice as a guessed solution to Eq.~\ref{eq:#1} is</latex_expansion>
      <comment>applies to differential equations</comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>boundaryCondition</infrule_name>
      <latex_expansion>A boundary condition for Eq.~\ref{eq:#1} is</latex_expansion>
      <comment>applies to differential equations</comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>1</number_of_output_statements>
   </inference_rule>
   <inference_rule>
      <infrule_name>declareFinalEq</infrule_name>
      <latex_expansion>Eq.~\ref{eq:#1} is one of the final equations.</latex_expansion>
      <comment>pass label of starting equation</comment>
      <cas_mathematica>Not applicable</cas_mathematica>
      <cas_sympy># Not applicable</cas_sympy>
      <number_of_arguments>1</number_of_arguments>
      <number_of_feeds>0</number_of_feeds>
      <number_of_input_statements>1</number_of_input_statements>
      <number_of_output_statements>0</number_of_output_statements>
   </inference_rule>
</inference_rule_list>
